# pa3

## Prerequisites
* You have installed Java and the JDK. These are available for download at https://www.oracle.com/java/technologies/downloads/

## How to run
* Go to the directory where the java files are located using cd
* To execute Problem 1, type java p1.java
* To execute Problem 2, type java p2.java

## Proof of correctness, efficiency, and experimental evaluation
My solution for problem 1 goes as follows: Each servant will be working until all thank you cards are written. The servants are to execute these three actions: add, remove then check if gift in chain. These three actions will take place concurrently between four threads, in no particular order. At a random time, the minotaur will request when to check if gift in chain. 

To implement this, I used a lock-free concurrent linked list. This was implemented using the AtomicMarkableReference class in Java. Each object in this class has a reference attribute and a marked flag. In my implementation, the reference pointed to type Node, which contained a key attribute and a next pointer of type AtomicMarkableReference<Node>. A Window class was used as a helper class to store current and previous nodes in the linked list. These allowed me to implement add, remove, find and contains in for my linked list. Add works by finding pred and curr then using compareAndSet to make sure the references were in tact. Remove also works by finding pred and curr then using compareAndSet to make sure the references were in tact. Find works by first deleting marked nodes then searching for desired node. 

I believe my solution is efficient for various reasons. For one, my solution provides a lock free way of adding and removing nodes from a linked list concurrently. My solution also uses wait free contains for finding gifts in the chain. These are among the most efficient features you can have for a concurrent data structure. This is the most optimal algorithm when the cost of scanning twice without locks is less than the cost of scanning once with locks. 

For experimental evaluation, I set a timer for before and after the thank you notes are finished. The main method will wait for all thank you notes to be made. With numPresents = 500,000 in my trail runs, my solution on average takes 5 seconds to make thank you cards. The gift also tends not to be found in the chain. This may be because we are checking for 1 gift out of a potential 500,000 gifts that are added and removed at any time. Therefore it is unlikely that a gift will be found at the minotaur's request. 

My solution for problem two goes as follows: there are three main states the threads can be in. These states are sensing, reporting and calculating. The sensing state will do multiple things. First it will increment the timer to represent a minute passing on Mars. For my implementation, 1 minute on Mars is equal to 150 milliseconds on Earth. If the modulo of the timer is equal to 0, then the solution will be in a report state as well as a sensing state. The sensing state then goes on to sense the temperature, mark the temperature just outside of the ten minute interval, then reset calculating variables. During the reporting state, a thread will compile the data calculated from the calculating state. The data will then be emptied to record the next hour's statistics. Both the reporting state and the sensing state will lock the calculating state from being executed. Upon the release of those two locks, the calculating state will execute 4 tasks: add newest reading to max heap, add to minheap, add and remove curr and prev to max ten, and add and remove curr and prev to min ten. The calculating stage will also calculate the difference and update if it was greater than the previos difference, along with the time interval it took place.

To implement this code, I used 5 data structures: a wait free queue and four heaps. There are two max heaps and two min heaps. These heaps are implemented using the PriorityQueue class in Java. There are two locks as well, one for sensing and one for reporting. As well there are task variables that allow the tasks to be split concurrently between the four heaps. Finally are the variables that keep track of time, sensors and intervals. Sensing is implemented in constant time with a random variable. At the end of the sensing stage, the thread is slept for 150 milliseconds to ensure that the sensor is not delayed. Reporting is implemented in klogn, where k=5 and n=60. Calculating is a four way split between heap operations and each operation takes O(Logn) time. Upating the interval is a constant time operation. Reporting was implemented using one thread since the critical sections could not be divided.

For experimental evaluation, I set a timer on both the sensing stage and the reporting stage to ensure they were within expected ranges. On average, the sensing stage took less than a millisecond to read the temperature. The reporting stage on average took 20 milliseconds. To ensure that the results were accurate for the intervals, I printed the queue to verify the intervals matched